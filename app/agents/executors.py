# app/agents/executors.py
from __future__ import annotations

import os
import time
import subprocess
from typing import Any, Dict, Optional

import requests

from app.agents.utils import run_cmd, git_has_changes
from app.agents.backend_scaffold import scaffold_node_backend
from app.agents.strict_planner import ExecutionPlan, PlanStep
from app.agents.failure_diagnoser import build_failure_context, diagnose_failure


MAX_RETRIES = 2  # strict, bounded retry


# ─────────────────────────────────────────────
# Utilities
# ─────────────────────────────────────────────

def _safe_makedirs_for_file(path: str) -> None:
    d = os.path.dirname(path) or "."
    os.makedirs(d, exist_ok=True)


def _write(path: str, content: str) -> None:
    _safe_makedirs_for_file(path)
    with open(path, "w", encoding="utf-8") as f:
        f.write(content)


def _append_if_missing(path: str, content: str, *, marker: Optional[str] = None) -> None:
    existing = ""
    if os.path.exists(path):
        existing = open(path, "r", encoding="utf-8", errors="replace").read()

    if marker and marker in existing:
        return
    if content.strip() and content.strip() in existing:
        return

    _safe_makedirs_for_file(path)
    with open(path, "a", encoding="utf-8") as f:
        if os.path.exists(path) and os.path.getsize(path) > 0:
            f.write("\n")
        f.write(content)


def _read_text(abs_path: str) -> str:
    with open(abs_path, "r", encoding="utf-8", errors="replace") as f:
        return f.read()


def _write_text(abs_path: str, content: str) -> None:
    _safe_makedirs_for_file(abs_path)
    with open(abs_path, "w", encoding="utf-8") as f:
        f.write(content)


# ─────────────────────────────────────────────
# Core helpers
# ─────────────────────────────────────────────

def safe_run_tests(repo_path: str) -> str:
    try:
        return run_cmd(["pytest", "-q"], cwd=repo_path)
    except Exception as e:
        return f"SKIPPED: {e}"


def capture_diff(repo_path: str) -> str:
    try:
        return run_cmd(["git", "diff"], cwd=repo_path)
    except Exception:
        return ""


def update_readme(repo_path: str, kind: str, prompt: str) -> None:
    readme_path = os.path.join(repo_path, "README_AUTOTRIAGE.md")

    if kind == "generated_project":
        _write(
            readme_path,
            "# Generated Project (AutoTriage)\n\n"
            f"Prompt:\n{prompt}\n\n"
            "This is a safe scaffold. Extend with real modules, tests, CI, and docs.\n",
        )
        return

    if kind == "how_to_run":
        _write(
            readme_path,
            "# How to Run (AutoTriage)\n\n"
            f"Prompt:\n{prompt}\n\n"
            "```bash\nnpm install\nnpm start\n```\n",
        )
        return

    _write(readme_path, f"# AutoTriage Output\n\nPrompt:\n{prompt}\n")


def add_env_example(repo_path: str, keys: list[str]) -> None:
    lines = ["# AutoTriage env example\n"]
    for k in keys:
        lines.append(f"{k}=YOUR_VALUE_HERE")
    lines.append("")
    _write(os.path.join(repo_path, ".env.example"), "\n".join(lines))


# ─────────────────────────────────────────────
# PR creation step (NO STATUS CHANGES HERE)
# ─────────────────────────────────────────────

def commit_push_pr(
    *,
    owner: str,
    repo: str,
    repo_path: str,
    job_id: int,
    store,
    jc,
    title: str,
    prompt: str,
    create_pr_fn,
) -> None:
    if not git_has_changes(repo_path):
        raise RuntimeError("No changes detected — PR-required action cannot continue")

    branch = f"autotriage/{int(time.time())}"

    run_cmd(["git", "checkout", "-b", branch], cwd=repo_path)
    run_cmd(["git", "add", "."], cwd=repo_path)
    run_cmd(["git", "commit", "-m", title], cwd=repo_path)
    run_cmd(["git", "push", "-u", "origin", branch], cwd=repo_path)

    jc.log("LOG", f"Pushed branch {branch}")

    pr = create_pr_fn(
        owner=owner,
        repo=repo,
        branch=branch,
        title=title,
        body=f"Generated by AutoTriage.\n\nPrompt:\n{prompt}",
    )

    store.set_pr(
        job_id,
        pr_number=pr["number"],
        pr_url=pr["html_url"],
        pr_head=branch,
        pr_base="main",
    )

    jc.log(
        "PR_CREATED",
        {
            "number": pr["number"],
            "url": pr["html_url"],
            "branch": branch,
        },
    )


# ─────────────────────────────────────────────
# Plan execution
# ─────────────────────────────────────────────

def execute_plan(
    plan: ExecutionPlan,
    *,
    owner: str,
    repo: str,
    repo_path: str,
    job_id: int,
    store,
    jc,
    create_pr_fn,
    action: str,
    prompt: str,
) -> None:
    for step in plan.steps:
        attempt = 0

        while True:
            try:
                attempt += 1
                if attempt > 1:
                    jc.log("RETRY", {"op": step.op, "attempt": attempt})

                _exec_step(
                    step=step,
                    owner=owner,
                    repo=repo,
                    repo_path=repo_path,
                    job_id=job_id,
                    store=store,
                    jc=jc,
                    create_pr_fn=create_pr_fn,
                    action=action,
                    prompt=prompt,
                )
                break

            except Exception as e:
                ctx = build_failure_context(
                    op=step.op,
                    args=step.args or {},
                    repo_path=repo_path,
                    owner=owner,
                    repo=repo,
                    job_id=job_id,
                    action=action,
                    prompt=prompt,
                    exc=e,
                )
                diagnosis = diagnose_failure(ctx)

                jc.log("FAILURE_CTX", ctx.to_dict())
                jc.log("DIAGNOSIS", diagnosis)

                if not diagnosis.get("retryable") or attempt >= MAX_RETRIES:
                    jc.log(
                        "RETRY_ABORT",
                        {
                            "op": step.op,
                            "attempts": attempt,
                            "reason": diagnosis.get("summary", "non-retryable"),
                        },
                    )
                    raise

                time.sleep(1)


def _exec_step(
    *,
    step: PlanStep,
    owner: str,
    repo: str,
    repo_path: str,
    job_id: int,
    store,
    jc,
    create_pr_fn,
    action: str,
    prompt: str,
) -> None:
    op = step.op
    args: Dict[str, Any] = step.args or {}

    if op == "ANALYZE_REPO":
        jc.log("LOG", {"op": op, "status": "ok"})
        return

    if op == "RUN_TESTS_SAFE":
        jc.log("RESULT", safe_run_tests(repo_path))
        return

    if op == "CAPTURE_DIFF":
        jc.log("DIFF", capture_diff(repo_path))
        return

    if op == "FORMAT_BLACK":
        run_cmd(["black", args.get("path", ".")], cwd=repo_path)
        jc.log("RESULT", {"op": op, "status": "ok"})
        return

    if op == "CREATE_FILE":
        abs_path = os.path.join(repo_path, args["path"])
        _write_text(abs_path, args.get("content", ""))
        jc.log("MODIFY", {"created": args["path"]})
        return

    if op == "EDIT_FILE":
        abs_path = os.path.join(repo_path, args["path"])
        text = _read_text(abs_path)
        updated = text.replace(args["old"], args["new"], args.get("max_replacements", 1))
        _write_text(abs_path, updated)
        jc.log("MODIFY", {"edited": args["path"]})
        return

    if op == "APPLY_PATCH":
        p = subprocess.run(
            ["git", "apply"],
            input=args["patch"],
            text=True,
            cwd=repo_path,
            capture_output=True,
        )
        if p.returncode != 0:
            raise RuntimeError(p.stderr)
        jc.log("MODIFY", {"patch_applied": True})
        return

    if op == "DELETE_FILE":
        os.remove(os.path.join(repo_path, args["path"]))
        jc.log("MODIFY", {"deleted": args["path"]})
        return

    if op == "APPEND_FILE":
        _append_if_missing(
            os.path.join(repo_path, args["path"]),
            args["content"],
            marker=args.get("marker"),
        )
        jc.log("MODIFY", {"appended": args["path"]})
        return

    if op == "SCAFFOLD_NODE_BACKEND":
        res = scaffold_node_backend(repo_path, args.get("prompt", ""))
        jc.log("MODIFY", {"backend": res})
        return

    if op == "ADD_ENV_EXAMPLE":
        add_env_example(repo_path, list(args.get("keys", [])))
        jc.log("MODIFY", {"env_example": True})
        return

    if op == "UPDATE_README":
        update_readme(repo_path, args.get("kind", "how_to_run"), args.get("prompt", ""))
        jc.log("MODIFY", {"readme": True})
        return

    if op == "COMMIT_PUSH_PR":
        commit_push_pr(
            owner=owner,
            repo=repo,
            repo_path=repo_path,
            job_id=job_id,
            store=store,
            jc=jc,
            title=args.get("title", "AutoTriage update"),
            prompt=prompt,
            create_pr_fn=create_pr_fn,
        )
        return

    raise RuntimeError(f"EXECUTOR_MISSING_FOR_OP: {op}")
