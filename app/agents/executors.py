# app/agents/executors.py
from __future__ import annotations

import os
import time
import subprocess
from typing import Any, Dict, Optional

import requests

from app.agents.utils import run_cmd, git_has_changes
from app.agents.backend_scaffold import scaffold_node_backend
from app.agents.strict_planner import ExecutionPlan, PlanStep
from app.agents.failure_diagnoser import build_failure_context, diagnose_failure


MAX_RETRIES = 2  # strict, bounded retry


def _safe_makedirs_for_file(path: str) -> None:
    d = os.path.dirname(path) or "."
    os.makedirs(d, exist_ok=True)


def _write(path: str, content: str) -> None:
    _safe_makedirs_for_file(path)
    with open(path, "w", encoding="utf-8") as f:
        f.write(content)


def _append_if_missing(path: str, content: str, *, marker: Optional[str] = None) -> None:
    """
    Deterministic append:
    - If marker provided and marker already exists, no-op.
    - If full content already exists, no-op.
    """
    _safe_makedirs_for_file(path)

    existing = ""
    if os.path.exists(path):
        existing = open(path, "r", encoding="utf-8", errors="replace").read()

    if marker and marker in existing:
        return

    if content.strip() and (content.strip() in existing):
        return

    with open(path, "a", encoding="utf-8") as f:
        if os.path.exists(path) and os.path.getsize(path) > 0:
            f.write("\n")
        f.write(content)


def safe_run_tests(repo_path: str) -> str:
    try:
        return run_cmd(["pytest", "-q"], cwd=repo_path)
    except Exception as e:
        return f"SKIPPED: {e}"


def capture_diff(repo_path: str) -> str:
    try:
        return run_cmd(["git", "diff"], cwd=repo_path)
    except Exception:
        return ""


def update_readme(repo_path: str, kind: str, prompt: str) -> None:
    readme_path = os.path.join(repo_path, "README_AUTOTRIAGE.md")

    if kind == "generated_project":
        _write(
            readme_path,
            "# Generated Project (AutoTriage)\n\n"
            f"Prompt:\n{prompt}\n\n"
            "This is a safe scaffold. Extend with real modules, tests, CI, and docs.\n",
        )
        return

    if kind == "how_to_run":
        _write(
            readme_path,
            "# How to Run (AutoTriage)\n\n"
            f"Prompt:\n{prompt}\n\n"
            "## Backend\n"
            "```bash\n"
            "cd backend\n"
            "npm install\n"
            "npm start\n"
            "```\n\n"
            "Health: `GET /api/health`\n\n"
            "Products: `GET /api/products`\n\n"
            "Cart: `GET /api/cart`, `POST /api/cart`\n\n"
            "Orders: `POST /api/order`\n",
        )
        return

    _write(readme_path, f"# AutoTriage Output\n\nPrompt:\n{prompt}\n")


def add_env_example(repo_path: str, keys: list[str]) -> None:
    content = ["# AutoTriage env example\n"]
    for k in keys:
        content.append(f"{k}=YOUR_VALUE_HERE")
    content.append("")
    _write(os.path.join(repo_path, ".env.example"), "\n".join(content))


def commit_push_pr(
    owner: str,
    repo: str,
    repo_path: str,
    job_id: int,
    store,
    jc,
    title: str,
    prompt: str,
    create_pr_fn,
) -> None:
    if not git_has_changes(repo_path):
        jc.log("RESULT", "No changes detected. Nothing to commit/PR.")
        store.update_agent_job_status(job_id, "COMPLETED")
        return

    branch = f"autotriage/{int(time.time())}"

    run_cmd(["git", "checkout", "-b", branch], cwd=repo_path)
    run_cmd(["git", "add", "."], cwd=repo_path)
    run_cmd(["git", "commit", "-m", title], cwd=repo_path)

    jc.log("LOG", f"Committed on branch {branch}")

    run_cmd(["git", "push", "-u", "origin", branch], cwd=repo_path)
    jc.log("LOG", "Branch pushed to origin")

    pr = create_pr_fn(
        owner=owner,
        repo=repo,
        branch=branch,
        title=title,
        body=f"Generated by AutoTriage.\n\nPrompt:\n{prompt}\n",
    )

    store.set_pr(
        job_id,
        pr_number=pr["number"],
        pr_url=pr["html_url"],
        pr_head=branch,
        pr_base="main",
    )

    jc.log("PR_CREATED", {"number": pr["number"], "url": pr["html_url"], "branch": branch})
    store.update_agent_job_status(job_id, "COMPLETED")


def execute_plan(
    plan: ExecutionPlan,
    *,
    owner: str,
    repo: str,
    repo_path: str,
    job_id: int,
    store,
    jc,
    create_pr_fn,
    action: str = "",
    prompt: str = "",
) -> None:
    """
    Step 6:
    - Per-step bounded retry loop
    - Retry only if diagnosis.retryable
    - All retries logged
    """
    for step in plan.steps:
        attempt = 0

        while True:
            try:
                attempt += 1
                if attempt > 1:
                    jc.log("RETRY", {"op": step.op, "attempt": attempt})

                _exec_step(
                    step=step,
                    owner=owner,
                    repo=repo,
                    repo_path=repo_path,
                    job_id=job_id,
                    store=store,
                    jc=jc,
                    create_pr_fn=create_pr_fn,
                    action=action,
                    prompt=prompt,
                )
                break  # success -> next step

            except Exception as e:
                ctx = build_failure_context(
                    op=step.op,
                    args=step.args or {},
                    repo_path=repo_path,
                    owner=owner,
                    repo=repo,
                    job_id=job_id,
                    action=action,
                    prompt=prompt,
                    exc=e,
                )
                diagnosis = diagnose_failure(ctx)

                jc.log("FAILURE_CTX", ctx.to_dict())
                jc.log("DIAGNOSIS", diagnosis)

                retryable = bool(diagnosis.get("retryable", False))

                if (not retryable) or attempt >= MAX_RETRIES:
                    jc.log(
                        "RETRY_ABORT",
                        {
                            "op": step.op,
                            "attempts": attempt,
                            "reason": diagnosis.get("summary", "non-retryable"),
                        },
                    )
                    raise

                time.sleep(1)  # controlled backoff


def _start_process(cmd: list[str], cwd: str) -> subprocess.Popen:
    return subprocess.Popen(
        cmd,
        cwd=cwd,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
    )


def _terminate_process(p: subprocess.Popen) -> None:
    try:
        if p.poll() is None:
            p.terminate()
            try:
                p.wait(timeout=3)
            except Exception:
                p.kill()
    except Exception:
        pass


def _read_text(abs_path: str) -> str:
    with open(abs_path, "r", encoding="utf-8", errors="replace") as f:
        return f.read()


def _write_text(abs_path: str, content: str) -> None:
    _safe_makedirs_for_file(abs_path)
    with open(abs_path, "w", encoding="utf-8") as f:
        f.write(content)


def _exec_step(
    *,
    step: PlanStep,
    owner: str,
    repo: str,
    repo_path: str,
    job_id: int,
    store,
    jc,
    create_pr_fn,
    action: str,
    prompt: str,
) -> None:
    op = step.op
    args: Dict[str, Any] = step.args or {}

    # ---------- CORE OPS ----------

    if op == "ANALYZE_REPO":
        # already logged in runner (facts)
        jc.log("LOG", {"op": op, "status": "ok"})
        return

    if op == "RUN_TESTS_SAFE":
        out = safe_run_tests(repo_path)
        jc.log("RESULT", out)
        return

    if op == "CAPTURE_DIFF":
        diff = capture_diff(repo_path)
        jc.log("DIFF", diff)
        return

    if op == "FORMAT_BLACK":
        path = str(args.get("path") or ".")
        best_effort = bool(args.get("best_effort", True))
        try:
            run_cmd(["black", path], cwd=repo_path)
            jc.log("RESULT", {"op": op, "status": "ok", "path": path})
        except Exception as e:
            if best_effort:
                jc.log("RESULT", {"op": op, "status": "skipped", "reason": str(e)})
            else:
                raise
        return

    # ---------- STEP 7/8: FILE MUTATION OPS ----------

    if op == "CREATE_FILE":
        rel = str(args.get("path") or "").strip()
        content = str(args.get("content") or "")
        if not rel:
            raise RuntimeError("CREATE_FILE missing path")
        abs_path = os.path.join(repo_path, rel)
        if os.path.exists(abs_path):
            raise RuntimeError(f"CREATE_FILE failed: {rel} already exists")

        _write_text(abs_path, content)
        jc.log("MODIFY", {"op": op, "created": rel, "bytes": len(content.encode("utf-8"))})
        return

    if op == "EDIT_FILE":
        rel = str(args.get("path") or "").strip()
        old = str(args.get("old") or "")
        new = str(args.get("new") or "")
        max_repl = int(args.get("max_replacements", 1))

        if not rel:
            raise RuntimeError("EDIT_FILE missing path")
        if old == "":
            raise RuntimeError("EDIT_FILE missing old snippet")

        abs_path = os.path.join(repo_path, rel)
        if not os.path.exists(abs_path):
            raise RuntimeError(f"EDIT_FILE failed: {rel} not found")

        text = _read_text(abs_path)
        if old not in text:
            raise RuntimeError("EDIT_FILE failed: target snippet not found")

        updated = text.replace(old, new, max_repl)
        _write_text(abs_path, updated)

        jc.log("MODIFY", {"op": op, "edited": rel, "max_replacements": max_repl})
        return

    if op == "APPLY_PATCH":
        patch = str(args.get("patch") or "")
        if not patch.strip():
            raise RuntimeError("APPLY_PATCH missing patch")

        p = subprocess.run(
            ["git", "apply", "--whitespace=nowarn"],
            input=patch,
            text=True,
            cwd=repo_path,
            capture_output=True,
        )
        if p.returncode != 0:
            raise RuntimeError(f"APPLY_PATCH failed:\n{p.stderr}")

        jc.log("MODIFY", {"op": op, "patch_applied": True})
        return

    if op == "DELETE_FILE":
        rel = str(args.get("path") or "").strip()
        if not rel:
            raise RuntimeError("DELETE_FILE missing path")
        abs_path = os.path.join(repo_path, rel)
        if not os.path.exists(abs_path):
            raise RuntimeError(f"DELETE_FILE failed: {rel} not found")

        os.remove(abs_path)
        jc.log("MODIFY", {"op": op, "deleted": rel})
        return

    if op == "APPEND_FILE":
        rel = str(args.get("path") or "").strip()
        content = str(args.get("content") or "")
        marker = args.get("marker")
        marker = str(marker) if marker is not None else None

        if not rel:
            raise RuntimeError("APPEND_FILE missing path")
        if not content.strip():
            raise RuntimeError("APPEND_FILE missing content")

        abs_path = os.path.join(repo_path, rel)
        if not os.path.exists(abs_path):
            raise RuntimeError(f"APPEND_FILE failed: {rel} not found")

        _append_if_missing(abs_path, content, marker=marker)
        jc.log("MODIFY", {"op": op, "appended": rel, "marker": marker or ""})
        return

    # ---------- BUILD OPS ----------

    if op == "SCAFFOLD_NODE_BACKEND":
        p = str(args.get("prompt") or "").strip()
        serve_frontend = bool(args.get("serve_frontend", True))
        with_auth_hint = bool(args.get("with_auth_hint", False))

        res = scaffold_node_backend(repo_path, p)
        jc.log("MODIFY", {"backend": res, "serve_frontend": serve_frontend, "auth_hint": with_auth_hint})
        return

    if op == "ADD_ENV_EXAMPLE":
        keys = args.get("keys") or []
        add_env_example(repo_path, list(keys))
        jc.log("MODIFY", {"env_example": ".env.example"})
        return

    if op == "UPDATE_README":
        kind = str(args.get("kind") or "how_to_run")
        p = str(args.get("prompt") or "")
        update_readme(repo_path, kind=kind, prompt=p)
        jc.log("MODIFY", {"readme": "README_AUTOTRIAGE.md", "kind": kind})
        return

    # ---------- STEP 4: VERIFICATION OPS ----------

    if op == "VERIFY_FILE_EXISTS":
        rel = str(args.get("path") or "").strip()
        if not rel:
            raise RuntimeError("VERIFY_FILE_EXISTS missing path")

        abs_path = os.path.join(repo_path, rel)
        if not os.path.exists(abs_path):
            raise RuntimeError(f"VERIFY_FILE_EXISTS failed: {rel}")

        jc.log("VERIFY", {"op": op, "path": rel, "status": "ok"})
        return

    if op == "VERIFY_CMD":
        cmd = args.get("cmd")
        rel_cwd = str(args.get("cwd") or "").strip()

        if not cmd or not isinstance(cmd, list):
            raise RuntimeError("VERIFY_CMD missing cmd (list)")

        cwd = os.path.join(repo_path, rel_cwd) if rel_cwd else repo_path
        out = run_cmd(cmd, cwd=cwd)
        jc.log("VERIFY", {"op": op, "cmd": cmd, "cwd": rel_cwd or ".", "status": "ok", "output": out[-1200:]})
        return

    if op == "VERIFY_HTTP_ENDPOINT":
        url = str(args.get("url") or "").strip()
        start_cmd = args.get("start_cmd")
        start_cwd = str(args.get("start_cwd") or "").strip()
        wait_seconds = float(args.get("wait_seconds", 1))
        timeout = float(args.get("timeout", 8))

        if not url:
            raise RuntimeError("VERIFY_HTTP_ENDPOINT missing url")

        proc: Optional[subprocess.Popen] = None
        try:
            if start_cmd:
                if not isinstance(start_cmd, list):
                    raise RuntimeError("VERIFY_HTTP_ENDPOINT start_cmd must be a list")
                cwd = os.path.join(repo_path, start_cwd) if start_cwd else repo_path
                proc = _start_process(start_cmd, cwd=cwd)
                time.sleep(wait_seconds)

            r = requests.get(url, timeout=timeout)
            if r.status_code >= 400:
                raise RuntimeError(f"HTTP {r.status_code}")

            jc.log("VERIFY", {"op": op, "url": url, "status": "ok", "code": r.status_code})
            return
        finally:
            if proc:
                _terminate_process(proc)

    # ---------- CONTROL OPS ----------

    if op == "SET_STATUS":
        status = str(args.get("status") or "")
        if not status:
            raise RuntimeError("SET_STATUS missing status")
        store.update_agent_job_status(job_id, status)
        return

    if op == "WAIT_FOR_APPROVAL":
        jc.log("LOG", "Waiting for approval")
        jc.wait_for_event("APPROVED")
        return

    if op == "COMMIT_PUSH_PR":
        title = str(args.get("title") or "AutoTriage: update")
        p = str(args.get("prompt") or "")
        commit_push_pr(
            owner=owner,
            repo=repo,
            repo_path=repo_path,
            job_id=job_id,
            store=store,
            jc=jc,
            title=title,
            prompt=p,
            create_pr_fn=create_pr_fn,
        )
        return

    # STRICT: unknown op => fail hard
    raise RuntimeError(f"EXECUTOR_MISSING_FOR_OP: {op}")
